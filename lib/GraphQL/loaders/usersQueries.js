"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUserFromSessionToken = exports.load = void 0;

var _graphql = require("graphql");

var _graphqlListFields = _interopRequireDefault(require("graphql-list-fields"));

var _node = _interopRequireDefault(require("parse/node"));

var _rest = _interopRequireDefault(require("../../rest"));

var _Auth = _interopRequireDefault(require("../../Auth"));

var _parseClassTypes = require("./parseClassTypes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getUserFromSessionToken = async (config, info, queryInfo) => {
  if (!info || !info.sessionToken) {
    throw new _node.default.Error(_node.default.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
  }

  const sessionToken = info.sessionToken;
  const selectedFields = (0, _graphqlListFields.default)(queryInfo);
  const {
    include
  } = (0, _parseClassTypes.extractKeysAndInclude)(selectedFields);
  const response = await _rest.default.find(config, _Auth.default.master(config), '_Session', {
    sessionToken
  }, {
    include: include.split(',').map(included => `user.${included}`).join(',')
  }, info.clientVersion);

  if (!response.results || response.results.length == 0 || !response.results[0].user) {
    throw new _node.default.Error(_node.default.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
  } else {
    const user = response.results[0].user;
    user.sessionToken = sessionToken;
    return user;
  }
};

exports.getUserFromSessionToken = getUserFromSessionToken;

const load = parseGraphQLSchema => {
  if (parseGraphQLSchema.isUsersClassDisabled) {
    return;
  }

  parseGraphQLSchema.addGraphQLQuery('viewer', {
    description: 'The viewer query can be used to return the current user data.',
    type: new _graphql.GraphQLNonNull(parseGraphQLSchema.viewerType),

    async resolve(_source, _args, context, queryInfo) {
      try {
        const {
          config,
          info
        } = context;
        return await getUserFromSessionToken(config, info, queryInfo);
      } catch (e) {
        parseGraphQLSchema.handleError(e);
      }
    }

  }, true, true);
};

exports.load = load;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9HcmFwaFFML2xvYWRlcnMvdXNlcnNRdWVyaWVzLmpzIl0sIm5hbWVzIjpbImdldFVzZXJGcm9tU2Vzc2lvblRva2VuIiwiY29uZmlnIiwiaW5mbyIsInF1ZXJ5SW5mbyIsInNlc3Npb25Ub2tlbiIsIlBhcnNlIiwiRXJyb3IiLCJJTlZBTElEX1NFU1NJT05fVE9LRU4iLCJzZWxlY3RlZEZpZWxkcyIsImluY2x1ZGUiLCJyZXNwb25zZSIsInJlc3QiLCJmaW5kIiwiQXV0aCIsIm1hc3RlciIsInNwbGl0IiwibWFwIiwiaW5jbHVkZWQiLCJqb2luIiwiY2xpZW50VmVyc2lvbiIsInJlc3VsdHMiLCJsZW5ndGgiLCJ1c2VyIiwibG9hZCIsInBhcnNlR3JhcGhRTFNjaGVtYSIsImlzVXNlcnNDbGFzc0Rpc2FibGVkIiwiYWRkR3JhcGhRTFF1ZXJ5IiwiZGVzY3JpcHRpb24iLCJ0eXBlIiwiR3JhcGhRTE5vbk51bGwiLCJ2aWV3ZXJUeXBlIiwicmVzb2x2ZSIsIl9zb3VyY2UiLCJfYXJncyIsImNvbnRleHQiLCJlIiwiaGFuZGxlRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBLE1BQU1BLHVCQUF1QixHQUFHLE9BQU9DLE1BQVAsRUFBZUMsSUFBZixFQUFxQkMsU0FBckIsS0FBbUM7QUFDakUsTUFBSSxDQUFDRCxJQUFELElBQVMsQ0FBQ0EsSUFBSSxDQUFDRSxZQUFuQixFQUFpQztBQUMvQixVQUFNLElBQUlDLGNBQU1DLEtBQVYsQ0FDSkQsY0FBTUMsS0FBTixDQUFZQyxxQkFEUixFQUVKLHVCQUZJLENBQU47QUFJRDs7QUFDRCxRQUFNSCxZQUFZLEdBQUdGLElBQUksQ0FBQ0UsWUFBMUI7QUFDQSxRQUFNSSxjQUFjLEdBQUcsZ0NBQWNMLFNBQWQsQ0FBdkI7QUFFQSxRQUFNO0FBQUVNLElBQUFBO0FBQUYsTUFBYyw0Q0FBc0JELGNBQXRCLENBQXBCO0FBQ0EsUUFBTUUsUUFBUSxHQUFHLE1BQU1DLGNBQUtDLElBQUwsQ0FDckJYLE1BRHFCLEVBRXJCWSxjQUFLQyxNQUFMLENBQVliLE1BQVosQ0FGcUIsRUFHckIsVUFIcUIsRUFJckI7QUFBRUcsSUFBQUE7QUFBRixHQUpxQixFQUtyQjtBQUNFSyxJQUFBQSxPQUFPLEVBQUVBLE9BQU8sQ0FDYk0sS0FETSxDQUNBLEdBREEsRUFFTkMsR0FGTSxDQUVGQyxRQUFRLElBQUssUUFBT0EsUUFBUyxFQUYzQixFQUdOQyxJQUhNLENBR0QsR0FIQztBQURYLEdBTHFCLEVBV3JCaEIsSUFBSSxDQUFDaUIsYUFYZ0IsQ0FBdkI7O0FBYUEsTUFDRSxDQUFDVCxRQUFRLENBQUNVLE9BQVYsSUFDQVYsUUFBUSxDQUFDVSxPQUFULENBQWlCQyxNQUFqQixJQUEyQixDQUQzQixJQUVBLENBQUNYLFFBQVEsQ0FBQ1UsT0FBVCxDQUFpQixDQUFqQixFQUFvQkUsSUFIdkIsRUFJRTtBQUNBLFVBQU0sSUFBSWpCLGNBQU1DLEtBQVYsQ0FDSkQsY0FBTUMsS0FBTixDQUFZQyxxQkFEUixFQUVKLHVCQUZJLENBQU47QUFJRCxHQVRELE1BU087QUFDTCxVQUFNZSxJQUFJLEdBQUdaLFFBQVEsQ0FBQ1UsT0FBVCxDQUFpQixDQUFqQixFQUFvQkUsSUFBakM7QUFDQUEsSUFBQUEsSUFBSSxDQUFDbEIsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxXQUFPa0IsSUFBUDtBQUNEO0FBQ0YsQ0F0Q0Q7Ozs7QUF3Q0EsTUFBTUMsSUFBSSxHQUFHQyxrQkFBa0IsSUFBSTtBQUNqQyxNQUFJQSxrQkFBa0IsQ0FBQ0Msb0JBQXZCLEVBQTZDO0FBQzNDO0FBQ0Q7O0FBRURELEVBQUFBLGtCQUFrQixDQUFDRSxlQUFuQixDQUNFLFFBREYsRUFFRTtBQUNFQyxJQUFBQSxXQUFXLEVBQ1QsK0RBRko7QUFHRUMsSUFBQUEsSUFBSSxFQUFFLElBQUlDLHVCQUFKLENBQW1CTCxrQkFBa0IsQ0FBQ00sVUFBdEMsQ0FIUjs7QUFJRSxVQUFNQyxPQUFOLENBQWNDLE9BQWQsRUFBdUJDLEtBQXZCLEVBQThCQyxPQUE5QixFQUF1Qy9CLFNBQXZDLEVBQWtEO0FBQ2hELFVBQUk7QUFDRixjQUFNO0FBQUVGLFVBQUFBLE1BQUY7QUFBVUMsVUFBQUE7QUFBVixZQUFtQmdDLE9BQXpCO0FBQ0EsZUFBTyxNQUFNbEMsdUJBQXVCLENBQUNDLE1BQUQsRUFBU0MsSUFBVCxFQUFlQyxTQUFmLENBQXBDO0FBQ0QsT0FIRCxDQUdFLE9BQU9nQyxDQUFQLEVBQVU7QUFDVlgsUUFBQUEsa0JBQWtCLENBQUNZLFdBQW5CLENBQStCRCxDQUEvQjtBQUNEO0FBQ0Y7O0FBWEgsR0FGRixFQWVFLElBZkYsRUFnQkUsSUFoQkY7QUFrQkQsQ0F2QkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcmFwaFFMTm9uTnVsbCB9IGZyb20gJ2dyYXBocWwnO1xuaW1wb3J0IGdldEZpZWxkTmFtZXMgZnJvbSAnZ3JhcGhxbC1saXN0LWZpZWxkcyc7XG5pbXBvcnQgUGFyc2UgZnJvbSAncGFyc2Uvbm9kZSc7XG5pbXBvcnQgcmVzdCBmcm9tICcuLi8uLi9yZXN0JztcbmltcG9ydCBBdXRoIGZyb20gJy4uLy4uL0F1dGgnO1xuaW1wb3J0IHsgZXh0cmFjdEtleXNBbmRJbmNsdWRlIH0gZnJvbSAnLi9wYXJzZUNsYXNzVHlwZXMnO1xuXG5jb25zdCBnZXRVc2VyRnJvbVNlc3Npb25Ub2tlbiA9IGFzeW5jIChjb25maWcsIGluZm8sIHF1ZXJ5SW5mbykgPT4ge1xuICBpZiAoIWluZm8gfHwgIWluZm8uc2Vzc2lvblRva2VuKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLFxuICAgICAgJ0ludmFsaWQgc2Vzc2lvbiB0b2tlbidcbiAgICApO1xuICB9XG4gIGNvbnN0IHNlc3Npb25Ub2tlbiA9IGluZm8uc2Vzc2lvblRva2VuO1xuICBjb25zdCBzZWxlY3RlZEZpZWxkcyA9IGdldEZpZWxkTmFtZXMocXVlcnlJbmZvKTtcblxuICBjb25zdCB7IGluY2x1ZGUgfSA9IGV4dHJhY3RLZXlzQW5kSW5jbHVkZShzZWxlY3RlZEZpZWxkcyk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzdC5maW5kKFxuICAgIGNvbmZpZyxcbiAgICBBdXRoLm1hc3Rlcihjb25maWcpLFxuICAgICdfU2Vzc2lvbicsXG4gICAgeyBzZXNzaW9uVG9rZW4gfSxcbiAgICB7XG4gICAgICBpbmNsdWRlOiBpbmNsdWRlXG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoaW5jbHVkZWQgPT4gYHVzZXIuJHtpbmNsdWRlZH1gKVxuICAgICAgICAuam9pbignLCcpLFxuICAgIH0sXG4gICAgaW5mby5jbGllbnRWZXJzaW9uXG4gICk7XG4gIGlmIChcbiAgICAhcmVzcG9uc2UucmVzdWx0cyB8fFxuICAgIHJlc3BvbnNlLnJlc3VsdHMubGVuZ3RoID09IDAgfHxcbiAgICAhcmVzcG9uc2UucmVzdWx0c1swXS51c2VyXG4gICkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLklOVkFMSURfU0VTU0lPTl9UT0tFTixcbiAgICAgICdJbnZhbGlkIHNlc3Npb24gdG9rZW4nXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB1c2VyID0gcmVzcG9uc2UucmVzdWx0c1swXS51c2VyO1xuICAgIHVzZXIuc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG59O1xuXG5jb25zdCBsb2FkID0gcGFyc2VHcmFwaFFMU2NoZW1hID0+IHtcbiAgaWYgKHBhcnNlR3JhcGhRTFNjaGVtYS5pc1VzZXJzQ2xhc3NEaXNhYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcnNlR3JhcGhRTFNjaGVtYS5hZGRHcmFwaFFMUXVlcnkoXG4gICAgJ3ZpZXdlcicsXG4gICAge1xuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICdUaGUgdmlld2VyIHF1ZXJ5IGNhbiBiZSB1c2VkIHRvIHJldHVybiB0aGUgY3VycmVudCB1c2VyIGRhdGEuJyxcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTm9uTnVsbChwYXJzZUdyYXBoUUxTY2hlbWEudmlld2VyVHlwZSksXG4gICAgICBhc3luYyByZXNvbHZlKF9zb3VyY2UsIF9hcmdzLCBjb250ZXh0LCBxdWVyeUluZm8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGNvbmZpZywgaW5mbyB9ID0gY29udGV4dDtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0VXNlckZyb21TZXNzaW9uVG9rZW4oY29uZmlnLCBpbmZvLCBxdWVyeUluZm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VHcmFwaFFMU2NoZW1hLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gICAgdHJ1ZSxcbiAgICB0cnVlXG4gICk7XG59O1xuXG5leHBvcnQgeyBsb2FkLCBnZXRVc2VyRnJvbVNlc3Npb25Ub2tlbiB9O1xuIl19