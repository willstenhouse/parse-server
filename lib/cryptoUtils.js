"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomHexString = randomHexString;
exports.randomString = randomString;
exports.newObjectId = newObjectId;
exports.newObjectTimeId = newObjectTimeId;
exports.newToken = newToken;
exports.md5Hash = md5Hash;

var _crypto = require("crypto");

var _uniqid = _interopRequireDefault(require("uniqid"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Returns a new random hex string of the given even size.
function randomHexString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomHexString is useless.');
  }

  if (size % 2 !== 0) {
    throw new Error('randomHexString size must be divisible by 2.');
  }

  return (0, _crypto.randomBytes)(size / 2).toString('hex');
} // Returns a new random alphanumeric string of the given size.
//
// Note: to simplify implementation, the result has slight modulo bias,
// because chars length of 62 doesn't divide the number of all bytes
// (256) evenly. Such bias is acceptable for most cases when the output
// length is long enough and doesn't need to be uniform.


function randomString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomString is useless.');
  }

  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789';
  let objectId = '';
  const bytes = (0, _crypto.randomBytes)(size);

  for (let i = 0; i < bytes.length; ++i) {
    objectId += chars[bytes.readUInt8(i) % chars.length];
  }

  return objectId;
} // Returns a new random alphanumeric string suitable for object ID.


function newObjectId(size = 10, useTime = false) {
  if (useTime) {
    return newObjectTimeId(size);
  }

  return randomString(size);
} // Returns a new random alphanumeric string suitable for object ID.


function newObjectTimeId(size = 8) {
  return `${_uniqid.default.time()}${size > 0 ? randomString(size) : ''}`;
} // Returns a new random hex string suitable for secure tokens.


function newToken() {
  return randomHexString(32);
}

function md5Hash(string) {
  return (0, _crypto.createHash)('md5').update(string).digest('hex');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jcnlwdG9VdGlscy5qcyJdLCJuYW1lcyI6WyJyYW5kb21IZXhTdHJpbmciLCJzaXplIiwiRXJyb3IiLCJ0b1N0cmluZyIsInJhbmRvbVN0cmluZyIsImNoYXJzIiwib2JqZWN0SWQiLCJieXRlcyIsImkiLCJsZW5ndGgiLCJyZWFkVUludDgiLCJuZXdPYmplY3RJZCIsInVzZVRpbWUiLCJuZXdPYmplY3RUaW1lSWQiLCJ1bmlxaWQiLCJ0aW1lIiwibmV3VG9rZW4iLCJtZDVIYXNoIiwic3RyaW5nIiwidXBkYXRlIiwiZGlnZXN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFQTs7QUFDQTs7OztBQUVBO0FBQ08sU0FBU0EsZUFBVCxDQUF5QkMsSUFBekIsRUFBK0M7QUFDcEQsTUFBSUEsSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDZCxVQUFNLElBQUlDLEtBQUosQ0FBVSx5Q0FBVixDQUFOO0FBQ0Q7O0FBQ0QsTUFBSUQsSUFBSSxHQUFHLENBQVAsS0FBYSxDQUFqQixFQUFvQjtBQUNsQixVQUFNLElBQUlDLEtBQUosQ0FBVSw4Q0FBVixDQUFOO0FBQ0Q7O0FBQ0QsU0FBTyx5QkFBWUQsSUFBSSxHQUFHLENBQW5CLEVBQXNCRSxRQUF0QixDQUErQixLQUEvQixDQUFQO0FBQ0QsQyxDQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0MsWUFBVCxDQUFzQkgsSUFBdEIsRUFBNEM7QUFDakQsTUFBSUEsSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDZCxVQUFNLElBQUlDLEtBQUosQ0FBVSxzQ0FBVixDQUFOO0FBQ0Q7O0FBQ0QsUUFBTUcsS0FBSyxHQUNULCtCQUErQiw0QkFBL0IsR0FBOEQsWUFEaEU7QUFFQSxNQUFJQyxRQUFRLEdBQUcsRUFBZjtBQUNBLFFBQU1DLEtBQUssR0FBRyx5QkFBWU4sSUFBWixDQUFkOztBQUNBLE9BQUssSUFBSU8sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQyxFQUFFRCxDQUFwQyxFQUF1QztBQUNyQ0YsSUFBQUEsUUFBUSxJQUFJRCxLQUFLLENBQUNFLEtBQUssQ0FBQ0csU0FBTixDQUFnQkYsQ0FBaEIsSUFBcUJILEtBQUssQ0FBQ0ksTUFBNUIsQ0FBakI7QUFDRDs7QUFDRCxTQUFPSCxRQUFQO0FBQ0QsQyxDQUVEOzs7QUFDTyxTQUFTSyxXQUFULENBQ0xWLElBQVksR0FBRyxFQURWLEVBRUxXLE9BQWdCLEdBQUcsS0FGZCxFQUdHO0FBQ1IsTUFBSUEsT0FBSixFQUFhO0FBQ1gsV0FBT0MsZUFBZSxDQUFDWixJQUFELENBQXRCO0FBQ0Q7O0FBQ0QsU0FBT0csWUFBWSxDQUFDSCxJQUFELENBQW5CO0FBQ0QsQyxDQUVEOzs7QUFDTyxTQUFTWSxlQUFULENBQXlCWixJQUFZLEdBQUcsQ0FBeEMsRUFBbUQ7QUFDeEQsU0FBUSxHQUFFYSxnQkFBT0MsSUFBUCxFQUFjLEdBQUVkLElBQUksR0FBRyxDQUFQLEdBQVdHLFlBQVksQ0FBQ0gsSUFBRCxDQUF2QixHQUFnQyxFQUFHLEVBQTdEO0FBQ0QsQyxDQUVEOzs7QUFDTyxTQUFTZSxRQUFULEdBQTRCO0FBQ2pDLFNBQU9oQixlQUFlLENBQUMsRUFBRCxDQUF0QjtBQUNEOztBQUVNLFNBQVNpQixPQUFULENBQWlCQyxNQUFqQixFQUF5QztBQUM5QyxTQUFPLHdCQUFXLEtBQVgsRUFDSkMsTUFESSxDQUNHRCxNQURILEVBRUpFLE1BRkksQ0FFRyxLQUZILENBQVA7QUFHRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbmltcG9ydCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB1bmlxaWQgZnJvbSAndW5pcWlkJztcblxuLy8gUmV0dXJucyBhIG5ldyByYW5kb20gaGV4IHN0cmluZyBvZiB0aGUgZ2l2ZW4gZXZlbiBzaXplLlxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUhleFN0cmluZyhzaXplOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWmVyby1sZW5ndGggcmFuZG9tSGV4U3RyaW5nIGlzIHVzZWxlc3MuJyk7XG4gIH1cbiAgaWYgKHNpemUgJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYW5kb21IZXhTdHJpbmcgc2l6ZSBtdXN0IGJlIGRpdmlzaWJsZSBieSAyLicpO1xuICB9XG4gIHJldHVybiByYW5kb21CeXRlcyhzaXplIC8gMikudG9TdHJpbmcoJ2hleCcpO1xufVxuXG4vLyBSZXR1cm5zIGEgbmV3IHJhbmRvbSBhbHBoYW51bWVyaWMgc3RyaW5nIG9mIHRoZSBnaXZlbiBzaXplLlxuLy9cbi8vIE5vdGU6IHRvIHNpbXBsaWZ5IGltcGxlbWVudGF0aW9uLCB0aGUgcmVzdWx0IGhhcyBzbGlnaHQgbW9kdWxvIGJpYXMsXG4vLyBiZWNhdXNlIGNoYXJzIGxlbmd0aCBvZiA2MiBkb2Vzbid0IGRpdmlkZSB0aGUgbnVtYmVyIG9mIGFsbCBieXRlc1xuLy8gKDI1NikgZXZlbmx5LiBTdWNoIGJpYXMgaXMgYWNjZXB0YWJsZSBmb3IgbW9zdCBjYXNlcyB3aGVuIHRoZSBvdXRwdXRcbi8vIGxlbmd0aCBpcyBsb25nIGVub3VnaCBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIHVuaWZvcm0uXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKHNpemU6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChzaXplID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdaZXJvLWxlbmd0aCByYW5kb21TdHJpbmcgaXMgdXNlbGVzcy4nKTtcbiAgfVxuICBjb25zdCBjaGFycyA9XG4gICAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OSc7XG4gIGxldCBvYmplY3RJZCA9ICcnO1xuICBjb25zdCBieXRlcyA9IHJhbmRvbUJ5dGVzKHNpemUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgb2JqZWN0SWQgKz0gY2hhcnNbYnl0ZXMucmVhZFVJbnQ4KGkpICUgY2hhcnMubGVuZ3RoXTtcbiAgfVxuICByZXR1cm4gb2JqZWN0SWQ7XG59XG5cbi8vIFJldHVybnMgYSBuZXcgcmFuZG9tIGFscGhhbnVtZXJpYyBzdHJpbmcgc3VpdGFibGUgZm9yIG9iamVjdCBJRC5cbmV4cG9ydCBmdW5jdGlvbiBuZXdPYmplY3RJZChcbiAgc2l6ZTogbnVtYmVyID0gMTAsXG4gIHVzZVRpbWU6IGJvb2xlYW4gPSBmYWxzZVxuKTogc3RyaW5nIHtcbiAgaWYgKHVzZVRpbWUpIHtcbiAgICByZXR1cm4gbmV3T2JqZWN0VGltZUlkKHNpemUpO1xuICB9XG4gIHJldHVybiByYW5kb21TdHJpbmcoc2l6ZSk7XG59XG5cbi8vIFJldHVybnMgYSBuZXcgcmFuZG9tIGFscGhhbnVtZXJpYyBzdHJpbmcgc3VpdGFibGUgZm9yIG9iamVjdCBJRC5cbmV4cG9ydCBmdW5jdGlvbiBuZXdPYmplY3RUaW1lSWQoc2l6ZTogbnVtYmVyID0gOCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHt1bmlxaWQudGltZSgpfSR7c2l6ZSA+IDAgPyByYW5kb21TdHJpbmcoc2l6ZSkgOiAnJ31gO1xufVxuXG4vLyBSZXR1cm5zIGEgbmV3IHJhbmRvbSBoZXggc3RyaW5nIHN1aXRhYmxlIGZvciBzZWN1cmUgdG9rZW5zLlxuZXhwb3J0IGZ1bmN0aW9uIG5ld1Rva2VuKCk6IHN0cmluZyB7XG4gIHJldHVybiByYW5kb21IZXhTdHJpbmcoMzIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWQ1SGFzaChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdtZDUnKVxuICAgIC51cGRhdGUoc3RyaW5nKVxuICAgIC5kaWdlc3QoJ2hleCcpO1xufVxuIl19