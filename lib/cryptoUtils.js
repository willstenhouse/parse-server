"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomHexString = randomHexString;
exports.randomString = randomString;
exports.newObjectId = newObjectId;
exports.newObjectTimeId = newObjectTimeId;
exports.newToken = newToken;
exports.md5Hash = md5Hash;

var _crypto = require("crypto");

var _uniqid = _interopRequireDefault(require("uniqid"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Returns a new random hex string of the given even size.
function randomHexString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomHexString is useless.');
  }

  if (size % 2 !== 0) {
    throw new Error('randomHexString size must be divisible by 2.');
  }

  return (0, _crypto.randomBytes)(size / 2).toString('hex');
} // Returns a new random alphanumeric string of the given size.
//
// Note: to simplify implementation, the result has slight modulo bias,
// because chars length of 62 doesn't divide the number of all bytes
// (256) evenly. Such bias is acceptable for most cases when the output
// length is long enough and doesn't need to be uniform.


function randomString(size) {
  if (size === 0) {
    throw new Error('Zero-length randomString is useless.');
  }

  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789';
  let objectId = '';
  const bytes = (0, _crypto.randomBytes)(size);

  for (let i = 0; i < bytes.length; ++i) {
    objectId += chars[bytes.readUInt8(i) % chars.length];
  }

  return objectId;
} // Returns a new random alphanumeric string suitable for object ID.


function newObjectId(size = 10, useTime = false) {
  if (useTime) {
    return newObjectTimeId(size);
  }

  return randomString(size);
} // Returns a new random alphanumeric string suitable for object ID.


function newObjectTimeId(size = 8) {
  return `${(0, _uniqid.default)()}${size > 0 ? randomString(size) : ''}`;
} // Returns a new random hex string suitable for secure tokens.


function newToken() {
  return randomHexString(32);
}

function md5Hash(string) {
  return (0, _crypto.createHash)('md5').update(string).digest('hex');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jcnlwdG9VdGlscy5qcyJdLCJuYW1lcyI6WyJyYW5kb21IZXhTdHJpbmciLCJzaXplIiwiRXJyb3IiLCJ0b1N0cmluZyIsInJhbmRvbVN0cmluZyIsImNoYXJzIiwib2JqZWN0SWQiLCJieXRlcyIsImkiLCJsZW5ndGgiLCJyZWFkVUludDgiLCJuZXdPYmplY3RJZCIsInVzZVRpbWUiLCJuZXdPYmplY3RUaW1lSWQiLCJuZXdUb2tlbiIsIm1kNUhhc2giLCJzdHJpbmciLCJ1cGRhdGUiLCJkaWdlc3QiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOzs7O0FBR0E7QUFDTyxTQUFTQSxlQUFULENBQXlCQyxJQUF6QixFQUErQztBQUNwRCxNQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNkLFVBQU0sSUFBSUMsS0FBSixDQUFVLHlDQUFWLENBQU47QUFDRDs7QUFDRCxNQUFJRCxJQUFJLEdBQUcsQ0FBUCxLQUFhLENBQWpCLEVBQW9CO0FBQ2xCLFVBQU0sSUFBSUMsS0FBSixDQUFVLDhDQUFWLENBQU47QUFDRDs7QUFDRCxTQUFPLHlCQUFZRCxJQUFJLEdBQUcsQ0FBbkIsRUFBc0JFLFFBQXRCLENBQStCLEtBQS9CLENBQVA7QUFDRCxDLENBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTQyxZQUFULENBQXNCSCxJQUF0QixFQUE0QztBQUNqRCxNQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNkLFVBQU0sSUFBSUMsS0FBSixDQUFVLHNDQUFWLENBQU47QUFDRDs7QUFDRCxRQUFNRyxLQUFLLEdBQ1QsK0JBQStCLDRCQUEvQixHQUE4RCxZQURoRTtBQUVBLE1BQUlDLFFBQVEsR0FBRyxFQUFmO0FBQ0EsUUFBTUMsS0FBSyxHQUFHLHlCQUFZTixJQUFaLENBQWQ7O0FBQ0EsT0FBSyxJQUFJTyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRCxLQUFLLENBQUNFLE1BQTFCLEVBQWtDLEVBQUVELENBQXBDLEVBQXVDO0FBQ3JDRixJQUFBQSxRQUFRLElBQUlELEtBQUssQ0FBQ0UsS0FBSyxDQUFDRyxTQUFOLENBQWdCRixDQUFoQixJQUFxQkgsS0FBSyxDQUFDSSxNQUE1QixDQUFqQjtBQUNEOztBQUNELFNBQU9ILFFBQVA7QUFDRCxDLENBRUQ7OztBQUNPLFNBQVNLLFdBQVQsQ0FBcUJWLElBQVksR0FBRyxFQUFwQyxFQUF3Q1csT0FBZ0IsR0FBRyxLQUEzRCxFQUEwRTtBQUMvRSxNQUFJQSxPQUFKLEVBQWE7QUFDWCxXQUFPQyxlQUFlLENBQUNaLElBQUQsQ0FBdEI7QUFDRDs7QUFDRCxTQUFPRyxZQUFZLENBQUNILElBQUQsQ0FBbkI7QUFDRCxDLENBRUQ7OztBQUNPLFNBQVNZLGVBQVQsQ0FBeUJaLElBQVksR0FBRyxDQUF4QyxFQUFtRDtBQUN4RCxTQUFRLEdBQUUsc0JBQVMsR0FBRUEsSUFBSSxHQUFHLENBQVAsR0FBV0csWUFBWSxDQUFDSCxJQUFELENBQXZCLEdBQWdDLEVBQUcsRUFBeEQ7QUFDRCxDLENBRUQ7OztBQUNPLFNBQVNhLFFBQVQsR0FBNEI7QUFDakMsU0FBT2QsZUFBZSxDQUFDLEVBQUQsQ0FBdEI7QUFDRDs7QUFFTSxTQUFTZSxPQUFULENBQWlCQyxNQUFqQixFQUF5QztBQUM5QyxTQUFPLHdCQUFXLEtBQVgsRUFDSkMsTUFESSxDQUNHRCxNQURILEVBRUpFLE1BRkksQ0FFRyxLQUZILENBQVA7QUFHRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5cbmltcG9ydCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB1bmlxaWQgZnJvbSAndW5pcWlkJztcblxuXG4vLyBSZXR1cm5zIGEgbmV3IHJhbmRvbSBoZXggc3RyaW5nIG9mIHRoZSBnaXZlbiBldmVuIHNpemUuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSGV4U3RyaW5nKHNpemU6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChzaXplID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdaZXJvLWxlbmd0aCByYW5kb21IZXhTdHJpbmcgaXMgdXNlbGVzcy4nKTtcbiAgfVxuICBpZiAoc2l6ZSAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhbmRvbUhleFN0cmluZyBzaXplIG11c3QgYmUgZGl2aXNpYmxlIGJ5IDIuJyk7XG4gIH1cbiAgcmV0dXJuIHJhbmRvbUJ5dGVzKHNpemUgLyAyKS50b1N0cmluZygnaGV4Jyk7XG59XG5cbi8vIFJldHVybnMgYSBuZXcgcmFuZG9tIGFscGhhbnVtZXJpYyBzdHJpbmcgb2YgdGhlIGdpdmVuIHNpemUuXG4vL1xuLy8gTm90ZTogdG8gc2ltcGxpZnkgaW1wbGVtZW50YXRpb24sIHRoZSByZXN1bHQgaGFzIHNsaWdodCBtb2R1bG8gYmlhcyxcbi8vIGJlY2F1c2UgY2hhcnMgbGVuZ3RoIG9mIDYyIGRvZXNuJ3QgZGl2aWRlIHRoZSBudW1iZXIgb2YgYWxsIGJ5dGVzXG4vLyAoMjU2KSBldmVubHkuIFN1Y2ggYmlhcyBpcyBhY2NlcHRhYmxlIGZvciBtb3N0IGNhc2VzIHdoZW4gdGhlIG91dHB1dFxuLy8gbGVuZ3RoIGlzIGxvbmcgZW5vdWdoIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgdW5pZm9ybS5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21TdHJpbmcoc2l6ZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHNpemUgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1plcm8tbGVuZ3RoIHJhbmRvbVN0cmluZyBpcyB1c2VsZXNzLicpO1xuICB9XG4gIGNvbnN0IGNoYXJzID1cbiAgICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JztcbiAgbGV0IG9iamVjdElkID0gJyc7XG4gIGNvbnN0IGJ5dGVzID0gcmFuZG9tQnl0ZXMoc2l6ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBvYmplY3RJZCArPSBjaGFyc1tieXRlcy5yZWFkVUludDgoaSkgJSBjaGFycy5sZW5ndGhdO1xuICB9XG4gIHJldHVybiBvYmplY3RJZDtcbn1cblxuLy8gUmV0dXJucyBhIG5ldyByYW5kb20gYWxwaGFudW1lcmljIHN0cmluZyBzdWl0YWJsZSBmb3Igb2JqZWN0IElELlxuZXhwb3J0IGZ1bmN0aW9uIG5ld09iamVjdElkKHNpemU6IG51bWJlciA9IDEwLCB1c2VUaW1lOiBib29sZWFuID0gZmFsc2UpOiBzdHJpbmcge1xuICBpZiAodXNlVGltZSkge1xuICAgIHJldHVybiBuZXdPYmplY3RUaW1lSWQoc2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHJhbmRvbVN0cmluZyhzaXplKTtcbn1cblxuLy8gUmV0dXJucyBhIG5ldyByYW5kb20gYWxwaGFudW1lcmljIHN0cmluZyBzdWl0YWJsZSBmb3Igb2JqZWN0IElELlxuZXhwb3J0IGZ1bmN0aW9uIG5ld09iamVjdFRpbWVJZChzaXplOiBudW1iZXIgPSA4KTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke3VuaXFpZCgpfSR7c2l6ZSA+IDAgPyByYW5kb21TdHJpbmcoc2l6ZSkgOiAnJ31gO1xufVxuXG4vLyBSZXR1cm5zIGEgbmV3IHJhbmRvbSBoZXggc3RyaW5nIHN1aXRhYmxlIGZvciBzZWN1cmUgdG9rZW5zLlxuZXhwb3J0IGZ1bmN0aW9uIG5ld1Rva2VuKCk6IHN0cmluZyB7XG4gIHJldHVybiByYW5kb21IZXhTdHJpbmcoMzIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWQ1SGFzaChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdtZDUnKVxuICAgIC51cGRhdGUoc3RyaW5nKVxuICAgIC5kaWdlc3QoJ2hleCcpO1xufVxuIl19