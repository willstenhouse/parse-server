"use strict";

var _HTTPResponse = _interopRequireDefault(require("./HTTPResponse"));

var _querystring = _interopRequireDefault(require("querystring"));

var _logger = _interopRequireDefault(require("../logger"));

var _followRedirects = require("follow-redirects");

var _url = require("url");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const clients = {
  'http:': _followRedirects.http,
  'https:': _followRedirects.https
};

function makeCallback(resolve, reject) {
  return function (response) {
    const chunks = [];
    response.on('data', chunk => {
      chunks.push(chunk);
    });
    response.on('end', () => {
      const body = Buffer.concat(chunks);
      const httpResponse = new _HTTPResponse.default(response, body); // Consider <200 && >= 400 as errors

      if (httpResponse.status < 200 || httpResponse.status >= 400) {
        return reject(httpResponse);
      } else {
        return resolve(httpResponse);
      }
    });
    response.on('error', reject);
  };
}

const encodeBody = function ({
  body,
  headers = {}
}) {
  if (typeof body !== 'object') {
    return {
      body,
      headers
    };
  }

  var contentTypeKeys = Object.keys(headers).filter(key => {
    return key.match(/content-type/i) != null;
  });

  if (contentTypeKeys.length == 0) {
    // no content type
    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded
    body = _querystring.default.stringify(body);
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
  } else {
    /* istanbul ignore next */
    if (contentTypeKeys.length > 1) {
      _logger.default.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');
    } // There maybe many, we'll just take the 1st one


    var contentType = contentTypeKeys[0];

    if (headers[contentType].match(/application\/json/i)) {
      body = JSON.stringify(body);
    } else if (headers[contentType].match(/application\/x-www-form-urlencoded/i)) {
      body = _querystring.default.stringify(body);
    }
  }

  return {
    body,
    headers
  };
};
/**
 * Makes an HTTP Request.
 *
 * **Available in Cloud Code only.**
 *
 * By default, Parse.Cloud.httpRequest does not follow redirects caused by HTTP 3xx response codes. You can use the followRedirects option in the {@link Parse.Cloud.HTTPOptions} object to change this behavior.
 *
 * Sample request:
 * ```
 * Parse.Cloud.httpRequest({
 *   url: 'http://www.parse.com/'
 * }).then(function(httpResponse) {
 *   // success
 *   console.log(httpResponse.text);
 * },function(httpResponse) {
 *   // error
 *   console.error('Request failed with response code ' + httpResponse.status);
 * });
 * ```
 *
 * @method httpRequest
 * @name Parse.Cloud.httpRequest
 * @param {Parse.Cloud.HTTPOptions} options The Parse.Cloud.HTTPOptions object that makes the request.
 * @return {Promise<Parse.Cloud.HTTPResponse>} A promise that will be resolved with a {@link Parse.Cloud.HTTPResponse} object when the request completes.
 */


module.exports = function httpRequest(options) {
  let url;

  try {
    url = (0, _url.parse)(options.url);
  } catch (e) {
    return Promise.reject(e);
  }

  options = Object.assign(options, encodeBody(options)); // support params options

  if (typeof options.params === 'object') {
    options.qs = options.params;
  } else if (typeof options.params === 'string') {
    options.qs = _querystring.default.parse(options.params);
  }

  const client = clients[url.protocol];

  if (!client) {
    return Promise.reject(`Unsupported protocol ${url.protocol}`);
  }

  const requestOptions = {
    method: options.method,
    port: Number(url.port),
    path: url.pathname,
    hostname: url.hostname,
    headers: options.headers,
    encoding: null,
    followRedirects: options.followRedirects === true
  };

  if (requestOptions.headers) {
    Object.keys(requestOptions.headers).forEach(key => {
      if (typeof requestOptions.headers[key] === 'undefined') {
        delete requestOptions.headers[key];
      }
    });
  }

  if (url.search) {
    options.qs = Object.assign({}, options.qs, _querystring.default.parse(url.query));
  }

  if (url.auth) {
    requestOptions.auth = url.auth;
  }

  if (options.qs) {
    requestOptions.path += `?${_querystring.default.stringify(options.qs)}`;
  }

  if (options.agent) {
    requestOptions.agent = options.agent;
  }

  return new Promise((resolve, reject) => {
    const req = client.request(requestOptions, makeCallback(resolve, reject, options));

    if (options.body) {
      req.write(options.body);
    }

    req.on('error', error => {
      reject(error);
    });
    req.end();
  });
};
/**
 * @typedef Parse.Cloud.HTTPOptions
 * @property {String|Object} body The body of the request. If it is a JSON object, then the Content-Type set in the headers must be application/x-www-form-urlencoded or application/json. You can also set this to a {@link Buffer} object to send raw bytes. If you use a Buffer, you should also set the Content-Type header explicitly to describe what these bytes represent.
 * @property {function} error The function that is called when the request fails. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {Boolean} followRedirects Whether to follow redirects caused by HTTP 3xx responses. Defaults to false.
 * @property {Object} headers The headers for the request.
 * @property {String} method The method of the request. GET, POST, PUT, DELETE, HEAD, and OPTIONS are supported. Will default to GET if not specified.
 * @property {String|Object} params The query portion of the url. You can pass a JSON object of key value pairs like params: {q : 'Sean Plott'} or a raw string like params:q=Sean Plott.
 * @property {function} success The function that is called when the request successfully completes. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {string} url The url to send the request to.
 */


module.exports.encodeBody = encodeBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbG91ZC1jb2RlL2h0dHBSZXF1ZXN0LmpzIl0sIm5hbWVzIjpbImNsaWVudHMiLCJodHRwIiwiaHR0cHMiLCJtYWtlQ2FsbGJhY2siLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJjaHVua3MiLCJvbiIsImNodW5rIiwicHVzaCIsImJvZHkiLCJCdWZmZXIiLCJjb25jYXQiLCJodHRwUmVzcG9uc2UiLCJIVFRQUmVzcG9uc2UiLCJzdGF0dXMiLCJlbmNvZGVCb2R5IiwiaGVhZGVycyIsImNvbnRlbnRUeXBlS2V5cyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJtYXRjaCIsImxlbmd0aCIsInF1ZXJ5c3RyaW5nIiwic3RyaW5naWZ5IiwibG9nIiwiZXJyb3IiLCJjb250ZW50VHlwZSIsIkpTT04iLCJtb2R1bGUiLCJleHBvcnRzIiwiaHR0cFJlcXVlc3QiLCJvcHRpb25zIiwidXJsIiwiZSIsIlByb21pc2UiLCJhc3NpZ24iLCJwYXJhbXMiLCJxcyIsInBhcnNlIiwiY2xpZW50IiwicHJvdG9jb2wiLCJyZXF1ZXN0T3B0aW9ucyIsIm1ldGhvZCIsInBvcnQiLCJOdW1iZXIiLCJwYXRoIiwicGF0aG5hbWUiLCJob3N0bmFtZSIsImVuY29kaW5nIiwiZm9sbG93UmVkaXJlY3RzIiwiZm9yRWFjaCIsInNlYXJjaCIsInF1ZXJ5IiwiYXV0aCIsImFnZW50IiwicmVxIiwicmVxdWVzdCIsIndyaXRlIiwiZW5kIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTUEsT0FBTyxHQUFHO0FBQ2QsV0FBU0MscUJBREs7QUFFZCxZQUFVQztBQUZJLENBQWhCOztBQUtBLFNBQVNDLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCQyxNQUEvQixFQUF1QztBQUNyQyxTQUFPLFVBQVVDLFFBQVYsRUFBb0I7QUFDekIsVUFBTUMsTUFBTSxHQUFHLEVBQWY7QUFDQUQsSUFBQUEsUUFBUSxD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RDs7QUFDRGdELElBQUFBLEdBQUcsQ0FBQ25ELEVBQUosQ0FBTyxPQUFQLEVBQWdCcUIsS0FBSyxJQUFJO0FBQ3ZCeEIsTUFBQUEsTUFBTSxDQUFDd0IsS0FBRCxDQUFOO0FBQ0QsS0FGRDtBQUdBOEIsSUFBQUEsR0FBRyxDQUFDRyxHQUFKO0FBQ0QsR0FaTSxDQUFQO0FBYUQsQ0EzREQ7QUE2REE7Ozs7Ozs7Ozs7Ozs7QUFZQTlCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlaEIsVUFBZixHQUE0QkEsVUFBNUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSFRUUFJlc3BvbnNlIGZyb20gJy4vSFRUUFJlc3BvbnNlJztcbmltcG9ydCBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBodHRwLCBodHRwcyB9IGZyb20gJ2ZvbGxvdy1yZWRpcmVjdHMnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd1cmwnO1xuXG5jb25zdCBjbGllbnRzID0ge1xuICAnaHR0cDonOiBodHRwLFxuICAnaHR0cHM6JzogaHR0cHMsXG59O1xuXG5mdW5jdGlvbiBtYWtlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICByZXNwb25zZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9KTtcbiAgICByZXNwb25zZS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcbiAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IG5ldyBIVFRQUmVzcG9uc2UocmVzcG9uc2UsIGJvZHkpO1xuXG4gICAgICAvLyBDb25zaWRlciA8MjAwICYmID49IDQwMCBhcyBlcnJvcnNcbiAgICAgIGlmIChodHRwUmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IGh0dHBSZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoaHR0cFJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGh0dHBSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgfTtcbn1cblxuY29uc3QgZW5jb2RlQm9keSA9IGZ1bmN0aW9uICh7IGJvZHksIGhlYWRlcnMgPSB7fSB9KSB7XG4gIGlmICh0eXBlb2YgYm9keSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4geyBib2R5LCBoZWFkZXJzIH07XG4gIH1cbiAgdmFyIGNvbnRlbnRUeXBlS2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbHRlcihrZXkgPT4ge1xuICAgIHJldHVybiBrZXkubWF0Y2goL2NvbnRlbnQtdHlwZS9pKSAhPSBudWxsO1xuICB9KTtcblxuICBpZiAoY29udGVudFR5cGVLZXlzLmxlbmd0aCA9PSAwKSB7XG4gICAgLy8gbm8gY29udGVudCB0eXBlXG4gICAgLy8gIEFzIHBlciBodHRwczovL3BhcnNlLmNvbS9kb2NzL2Nsb3VkY29kZS9ndWlkZSNjbG91ZC1jb2RlLWFkdmFuY2VkLXNlbmRpbmctYS1wb3N0LXJlcXVlc3QgdGhlIGRlZmF1bHQgZW5jb2RpbmcgaXMgc3VwcG9zZWRseSB4LXd3dy1mb3JtLXVybGVuY29kZWRcblxuICAgIGJvZHkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkoYm9keSk7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChjb250ZW50VHlwZUtleXMubGVuZ3RoID4gMSkge1xuICAgICAgbG9nLmVycm9yKFxuICAgICAgICAnUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3QnLFxuICAgICAgICAnbXVsdGlwbGUgY29udGVudC10eXBlIGhlYWRlcnMgYXJlIHNldC4nXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBUaGVyZSBtYXliZSBtYW55LCB3ZSdsbCBqdXN0IHRha2UgdGhlIDFzdCBvbmVcbiAgICB2YXIgY29udGVudFR5cGUgPSBjb250ZW50VHlwZUtleXNbMF07XG4gICAgaWYgKGhlYWRlcnNbY29udGVudFR5cGVdLm1hdGNoKC9hcHBsaWNhdGlvblxcL2pzb24vaSkpIHtcbiAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaGVhZGVyc1tjb250ZW50VHlwZV0ubWF0Y2goL2FwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkL2kpXG4gICAgKSB7XG4gICAgICBib2R5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGJvZHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBib2R5LCBoZWFkZXJzIH07XG59O1xuXG4vKipcbiAqIE1ha2VzIGFuIEhUVFAgUmVxdWVzdC5cbiAqXG4gKiAqKkF2YWlsYWJsZSBpbiBDbG91ZCBDb2RlIG9ubHkuKipcbiAqXG4gKiBCeSBkZWZhdWx0LCBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdCBkb2VzIG5vdCBmb2xsb3cgcmVkaXJlY3RzIGNhdXNlZCBieSBIVFRQIDN4eCByZXNwb25zZSBjb2Rlcy4gWW91IGNhbiB1c2UgdGhlIGZvbGxvd1JlZGlyZWN0cyBvcHRpb24gaW4gdGhlIHtAbGluayBQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc30gb2JqZWN0IHRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yLlxuICpcbiAqIFNhbXBsZSByZXF1ZXN0OlxuICogYGBgXG4gKiBQYXJzZS5DbG91ZC5odHRwUmVxdWVzdCh7XG4gKiAgIHVybDogJ2h0dHA6Ly93d3cucGFyc2UuY29tLydcbiAqIH0pLnRoZW4oZnVuY3Rpb24oaHR0cFJlc3BvbnNlKSB7XG4gKiAgIC8vIHN1Y2Nlc3NcbiAqICAgY29uc29sZS5sb2coaHR0cFJlc3BvbnNlLnRleHQpO1xuICogfSxmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAqICAgLy8gZXJyb3JcbiAqICAgY29uc29sZS5lcnJvcignUmVxdWVzdCBmYWlsZWQgd2l0aCByZXNwb25zZSBjb2RlICcgKyBodHRwUmVzcG9uc2Uuc3RhdHVzKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQG1ldGhvZCBodHRwUmVxdWVzdFxuICogQG5hbWUgUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3RcbiAqIEBwYXJhbSB7UGFyc2UuQ2xvdWQuSFRUUE9wdGlvbnN9IG9wdGlvbnMgVGhlIFBhcnNlLkNsb3VkLkhUVFBPcHRpb25zIG9iamVjdCB0aGF0IG1ha2VzIHRoZSByZXF1ZXN0LlxuICogQHJldHVybiB7UHJvbWlzZTxQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYSB7QGxpbmsgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlfSBvYmplY3Qgd2hlbiB0aGUgcmVxdWVzdCBjb21wbGV0ZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICBsZXQgdXJsO1xuICB0cnkge1xuICAgIHVybCA9IHBhcnNlKG9wdGlvbnMudXJsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCBlbmNvZGVCb2R5KG9wdGlvbnMpKTtcbiAgLy8gc3VwcG9ydCBwYXJhbXMgb3B0aW9uc1xuICBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMucXMgPSBvcHRpb25zLnBhcmFtcztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucy5xcyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKG9wdGlvbnMucGFyYW1zKTtcbiAgfVxuICBjb25zdCBjbGllbnQgPSBjbGllbnRzW3VybC5wcm90b2NvbF07XG4gIGlmICghY2xpZW50KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBVbnN1cHBvcnRlZCBwcm90b2NvbCAke3VybC5wcm90b2NvbH1gKTtcbiAgfVxuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIHBvcnQ6IE51bWJlcih1cmwucG9ydCksXG4gICAgcGF0aDogdXJsLnBhdGhuYW1lLFxuICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzLFxuICAgIGVuY29kaW5nOiBudWxsLFxuICAgIGZvbGxvd1JlZGlyZWN0czogb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IHRydWUsXG4gIH07XG4gIGlmIChyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgT2JqZWN0LmtleXMocmVxdWVzdE9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICBvcHRpb25zLnFzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5xcywgcXVlcnlzdHJpbmcucGFyc2UodXJsLnF1ZXJ5KSk7XG4gIH1cbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuYXV0aCA9IHVybC5hdXRoO1xuICB9XG4gIGlmIChvcHRpb25zLnFzKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMucGF0aCArPSBgPyR7cXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9wdGlvbnMucXMpfWA7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICByZXF1ZXN0T3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXEgPSBjbGllbnQucmVxdWVzdChcbiAgICAgIHJlcXVlc3RPcHRpb25zLFxuICAgICAgbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgb3B0aW9ucylcbiAgICApO1xuICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgIHJlcS53cml0ZShvcHRpb25zLmJvZHkpO1xuICAgIH1cbiAgICByZXEub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXEuZW5kKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBQYXJzZS5DbG91ZC5IVFRQT3B0aW9uc1xuICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBib2R5IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0LiBJZiBpdCBpcyBhIEpTT04gb2JqZWN0LCB0aGVuIHRoZSBDb250ZW50LVR5cGUgc2V0IGluIHRoZSBoZWFkZXJzIG11c3QgYmUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIG9yIGFwcGxpY2F0aW9uL2pzb24uIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIHtAbGluayBCdWZmZXJ9IG9iamVjdCB0byBzZW5kIHJhdyBieXRlcy4gSWYgeW91IHVzZSBhIEJ1ZmZlciwgeW91IHNob3VsZCBhbHNvIHNldCB0aGUgQ29udGVudC1UeXBlIGhlYWRlciBleHBsaWNpdGx5IHRvIGRlc2NyaWJlIHdoYXQgdGhlc2UgYnl0ZXMgcmVwcmVzZW50LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXJyb3IgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHMuIEl0IHdpbGwgYmUgcGFzc2VkIGEgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZm9sbG93UmVkaXJlY3RzIFdoZXRoZXIgdG8gZm9sbG93IHJlZGlyZWN0cyBjYXVzZWQgYnkgSFRUUCAzeHggcmVzcG9uc2VzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdC4gR0VULCBQT1NULCBQVVQsIERFTEVURSwgSEVBRCwgYW5kIE9QVElPTlMgYXJlIHN1cHBvcnRlZC4gV2lsbCBkZWZhdWx0IHRvIEdFVCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBwYXJhbXMgVGhlIHF1ZXJ5IHBvcnRpb24gb2YgdGhlIHVybC4gWW91IGNhbiBwYXNzIGEgSlNPTiBvYmplY3Qgb2Yga2V5IHZhbHVlIHBhaXJzIGxpa2UgcGFyYW1zOiB7cSA6ICdTZWFuIFBsb3R0J30gb3IgYSByYXcgc3RyaW5nIGxpa2UgcGFyYW1zOnE9U2VhbiBQbG90dC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHN1Y2Nlc3MgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy4gSXQgd2lsbCBiZSBwYXNzZWQgYSBQYXJzZS5DbG91ZC5IVFRQUmVzcG9uc2Ugb2JqZWN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCBUaGUgdXJsIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlQm9keSA9IGVuY29kZUJvZHk7XG4iXX0=